"""Euler 29: distinct terms in a power sequence

How many distinct terms are in the sequence generated by 
a**b
for 2 <= a,b <= 100

so we could do this brute forcically, but methinks the easier way is using
the previously-built methods of decoding prime factorizations. Since a number 
to a power will generate the same prime factorization multiplied by that 
power, we can perform multiplication on 99 lists rather than 
exponentiation.

"""

class primeList(object):
	primes=[2]
	def __init__(self,n=100):
		self.primes=self.add_n(n)
	def getList(self):
		return self.primes
	def add_n(self,n):
		i=max(self.primes)+1
		while len(self.primes) < n:
			self.add_if_prime(i)
			i+=1
		return self.primes
	def add_til(self,x):
		i=max(self.primes)+1
		while max(self.primes) < x:
			self.add_if_prime(i,self.primes)
			i+=1
		return self.primes
	def add_if_prime(self,i):
		maybe=True
		for prime in self.primes:
			if i%prime==0:
				maybe=False
				break
		if maybe: self.primes.append(i)

# return prime factorization of n
def pfact(n,primes=primeList()):
	pf=[0]
	remainder=n
	i=0
	while remainder > 1:
		try:
			if remainder%primes.getList()[i]==0:
				remainder/=primes.getList()[i]
				pf[i]+=1
			else:
				i+=1
				pf.append(0)
		except IndexError:
			primes.add_til(remainder/2)
	return pf

pflist = []
pl=primeList(100)
for i in range(2,101):
	pflist.append(pfact(i,pl))

# print pflist

def scalXvect(scalar,vector):
	nv=[]
	for i in range(0,len(vector)):
		nv.append(scalar*vector[i])
	return nv

def powlist(pflist,n):
	powlist=[]
	for pf in pflist:
		for i in range(2,n+1):
			powpf=scalXvect(i,pf)
			if powpf not in powlist:
				powlist.append(powpf)
	return powlist

finallist=powlist(pflist,100)
print len(finallist)
